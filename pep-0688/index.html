
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="color-scheme" content="light dark" />
    <title>PEP 688 – Making the buffer protocol accessible in Python | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png"/>
    <link rel="canonical" href="https://peps.python.org/pep-0688.html" />
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/mq.css" type="text/css" />
    <link rel="stylesheet" href="../_static/dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="css-dark"/>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg" />
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark" />
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://www.python.org/dev/peps/peps.rss">
    <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <meta name="description" content="Python Enhancement Proposals (PEPs)"/>
</head>
<body>
    <section id="pep-page-section">
        <header>
            <h1>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 688</li>
            </ul>
            <button aria-label="Toggle dark mode" onClick="toggleColourScheme()"></button>
        </header>
        <article>
            <section id="pep-content">
<h1 class="page-title">PEP 688 – Making the buffer protocol accessible in Python</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author</dt>
<dd class="field-odd">Jelle Zijlstra &lt;jelle.zijlstra&#32;&#97;t&#32;gmail.com&gt;</dd>
<dt class="field-even">Discussions-To</dt>
<dd class="field-even"><a class="reference external" href="https://discuss.python.org/t/15265">Discourse thread</a></dd>
<dt class="field-odd">Status</dt>
<dd class="field-odd">Draft</dd>
<dt class="field-even">Type</dt>
<dd class="field-even">Standards Track</dd>
<dt class="field-odd">Created</dt>
<dd class="field-odd">23-Apr-2022</dd>
<dt class="field-even">Python-Version</dt>
<dd class="field-even">3.12</dd>
<dt class="field-odd">Post-History</dt>
<dd class="field-odd"><a class="reference external" href="https://mail.python.org/archives/list/typing-sig&#64;python.org/thread/CX7GPSIYQEL23RXMYL66GAKGP4RLUD7P/" title="Typing-SIG thread">23-Apr-2022</a>,
<a class="reference external" href="https://discuss.python.org/t/15265" title="Discourse thread">25-Apr-2022</a></dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#rationale">Rationale</a><ul>
<li><a class="reference internal" href="#current-options">Current options</a></li>
<li><a class="reference internal" href="#kinds-of-buffers">Kinds of buffers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#types-buffer">types.Buffer</a></li>
<li><a class="reference internal" href="#usage-in-stub-files">Usage in stub files</a></li>
<li><a class="reference internal" href="#equivalent-for-older-python-versions">Equivalent for older Python versions</a></li>
<li><a class="reference internal" href="#no-special-meaning-for-bytes">No special meaning for <code class="docutils literal notranslate"><span class="pre">bytes</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#how-to-teach-this">How to Teach This</a></li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#rejected-ideas">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#buffer-abc">Buffer ABC</a></li>
<li><a class="reference internal" href="#keep-bytearray-compatible-with-bytes">Keep <code class="docutils literal notranslate"><span class="pre">bytearray</span></code> compatible with <code class="docutils literal notranslate"><span class="pre">bytes</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#open-issues">Open Issues</a><ul>
<li><a class="reference internal" href="#read-only-and-writable-buffers">Read-only and writable buffers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract">Abstract</a></h2>
<p>This PEP proposes a mechanism for Python code to inspect whether a
type supports the C-level buffer protocol. This allows type
checkers to evaluate whether objects implement the protocol.</p>
</section>
<section id="motivation">
<h2><a class="toc-backref" href="#motivation">Motivation</a></h2>
<p>The CPython C API provides a versatile mechanism for accessing the
underlying memory of an object—the <a class="reference external" href="https://docs.python.org/3/c-api/buffer.html">buffer protocol</a>
introduced in <a class="pep reference internal" href="../pep-3118" title="PEP 3118 – Revising the buffer protocol">PEP 3118</a>.
Functions that accept binary data are usually written to handle any
object implementing the buffer protocol. For example, at the time of writing,
there are around 130 functions in CPython using the Argument Clinic
<code class="docutils literal notranslate"><span class="pre">Py_buffer</span></code> type, which accepts the buffer protocol.</p>
<p>Currently, there is no way for Python code to inspect whether an object
supports the buffer protocol. Moreover, the static type system
does not provide a type annotation to represent the protocol.
This is a <a class="reference external" href="https://github.com/python/typing/issues/593">common problem</a>
when writing type annotations for code that accepts generic buffers.</p>
</section>
<section id="rationale">
<h2><a class="toc-backref" href="#rationale">Rationale</a></h2>
<section id="current-options">
<h3><a class="toc-backref" href="#current-options">Current options</a></h3>
<p>There are two current workarounds for annotating buffer types in
the type system, but neither is adequate.</p>
<p>First, the <a class="reference external" href="https://github.com/python/typeshed/blob/2a0fc1b582ef84f7a82c0beb39fa617de2539d3d/stdlib/_typeshed/__init__.pyi#L194">current workaround</a>
for buffer types in typeshed is a type alias
that lists well-known buffer types in the standard library, such as
<code class="docutils literal notranslate"><span class="pre">bytes</span></code>, <code class="docutils literal notranslate"><span class="pre">bytearray</span></code>, <code class="docutils literal notranslate"><span class="pre">memoryview</span></code>, and <code class="docutils literal notranslate"><span class="pre">array.array</span></code>. This
approach works for the standard library, but it does not extend to
third-party buffer types.</p>
<p>Second, the <a class="reference external" href="https://docs.python.org/3.10/library/typing.html#typing.ByteString">documentation</a>
for <code class="docutils literal notranslate"><span class="pre">typing.ByteString</span></code> currently states:</p>
<blockquote>
<div>This type represents the types <code class="docutils literal notranslate"><span class="pre">bytes</span></code>, <code class="docutils literal notranslate"><span class="pre">bytearray</span></code>, and
<code class="docutils literal notranslate"><span class="pre">memoryview</span></code> of byte sequences.<p>As a shorthand for this type, <code class="docutils literal notranslate"><span class="pre">bytes</span></code> can be used to annotate
arguments of any of the types mentioned above.</p>
</div></blockquote>
<p>Although this sentence has been in the documentation
<a class="reference external" href="https://github.com/python/cpython/commit/2a19d956ab92fc9084a105cc11292cb0438b322f">since 2015</a>,
the use of <code class="docutils literal notranslate"><span class="pre">bytes</span></code> to include these other types is not specified
in any of the typing PEPs. Furthermore, this mechanism has a number of
problems. It does not include all possible buffer types, and it
makes the <code class="docutils literal notranslate"><span class="pre">bytes</span></code> type ambiguous in type annotations. After all,
there are many operations that are valid on <code class="docutils literal notranslate"><span class="pre">bytes</span></code> objects, but
not on <code class="docutils literal notranslate"><span class="pre">memoryview</span></code> objects, and it is perfectly possible for
a function to accept <code class="docutils literal notranslate"><span class="pre">bytes</span></code> but not <code class="docutils literal notranslate"><span class="pre">memoryview</span></code> objects.
A mypy user
<a class="reference external" href="https://github.com/python/mypy/issues/12643#issuecomment-1105914159">reports</a>
that this shortcut has caused significant problems for the <code class="docutils literal notranslate"><span class="pre">psycopg</span></code> project.</p>
</section>
<section id="kinds-of-buffers">
<h3><a class="toc-backref" href="#kinds-of-buffers">Kinds of buffers</a></h3>
<p>The C buffer protocol supports
<a class="reference external" href="https://docs.python.org/3.10/c-api/buffer.html#buffer-request-types">many options</a>,
affecting strides, contiguity, and support for writing to the buffer. Some of these
options would be useful in the type system. For example, typeshed
currently provides separate type aliases for writable and read-only
buffers.</p>
<p>However, in the C buffer protocol, these options cannot be
queried directly on the type object. The only way to figure out
whether an object supports a writable buffer is to actually
ask for the buffer. For some types, such as <code class="docutils literal notranslate"><span class="pre">memoryview</span></code>,
whether the buffer is writable depends on the instance:
some instances are read-only and others are not. As such, we propose to
expose only whether a type implements the buffer protocol at
all, not whether it supports more specific options such as
writable buffers.</p>
</section>
</section>
<section id="specification">
<h2><a class="toc-backref" href="#specification">Specification</a></h2>
<section id="types-buffer">
<h3><a class="toc-backref" href="#types-buffer">types.Buffer</a></h3>
<p>A new class, <code class="docutils literal notranslate"><span class="pre">types.Buffer</span></code>, will be added. It cannot be instantiated or
subclassed at runtime, but supports the <code class="docutils literal notranslate"><span class="pre">__instancecheck__</span></code> and
<code class="docutils literal notranslate"><span class="pre">__subclasscheck__</span></code> hooks.  In CPython, these will check for the presence of the
<code class="docutils literal notranslate"><span class="pre">bf_getbuffer</span></code> slot in the type object:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">Buffer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;xy&quot;</span><span class="p">,</span> <span class="n">Buffer</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">issubclass</span><span class="p">(</span><span class="nb">bytes</span><span class="p">,</span> <span class="n">Buffer</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">issubclass</span><span class="p">(</span><span class="nb">memoryview</span><span class="p">,</span> <span class="n">Buffer</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="s2">&quot;xy&quot;</span><span class="p">,</span> <span class="n">Buffer</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">issubclass</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Buffer</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The new class can also be used in type annotations:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">need_buffer</span><span class="p">(</span><span class="n">b</span><span class="p">:</span> <span class="n">Buffer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">memoryview</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

<span class="n">need_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;xy&quot;</span><span class="p">)</span>  <span class="c1"># ok</span>
<span class="n">need_buffer</span><span class="p">(</span><span class="s2">&quot;xy&quot;</span><span class="p">)</span>  <span class="c1"># rejected by static type checkers</span>
</pre></div>
</div>
</section>
<section id="usage-in-stub-files">
<h3><a class="toc-backref" href="#usage-in-stub-files">Usage in stub files</a></h3>
<p>For static typing purposes, types defined in C extensions usually
require stub files, as <a class="pep reference internal" href="../pep-0484#stub-files" title="PEP 484 – Type Hints § Stub Files">described in PEP 484</a>.
In stub files, <code class="docutils literal notranslate"><span class="pre">types.Buffer</span></code> may be used as a base class to
indicate that a class implements the buffer protocol.</p>
<p>For example, <code class="docutils literal notranslate"><span class="pre">memoryview</span></code> may be declared as follows in a stub:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">memoryview</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">Buffer</span><span class="p">,</span> <span class="n">Sized</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">types.Buffer</span></code> class does not require any special treatment
by type checkers.</p>
</section>
<section id="equivalent-for-older-python-versions">
<h3><a class="toc-backref" href="#equivalent-for-older-python-versions">Equivalent for older Python versions</a></h3>
<p>New typing features are usually backported to older Python versions
in the <a class="reference external" href="https://pypi.org/project/typing-extensions/">typing_extensions</a>
package. Because the buffer protocol
is accessible only in C, <code class="docutils literal notranslate"><span class="pre">types.Buffer</span></code> cannot be implemented
in a pure-Python package like <code class="docutils literal notranslate"><span class="pre">typing_extensions</span></code>. As a temporary
workaround, a <code class="docutils literal notranslate"><span class="pre">typing_extensions.Buffer</span></code>
<a class="reference internal" href="#buffer-abc">abstract base class</a> will be provided for Python versions
that do not have <code class="docutils literal notranslate"><span class="pre">types.Buffer</span></code> available.</p>
<p>For the benefit of
static type checkers, <code class="docutils literal notranslate"><span class="pre">typing_extensions.Buffer</span></code> can be used as
a base class in stubs to mark types as supporting the buffer protocol.
For runtime uses, the <code class="docutils literal notranslate"><span class="pre">ABC.register</span></code> API can be used to register
buffer classes with <code class="docutils literal notranslate"><span class="pre">typing_extensions.Buffer</span></code>.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">types.Buffer</span></code> is available, <code class="docutils literal notranslate"><span class="pre">typing_extensions</span></code> should simply
re-export it. Thus, users who register their buffer class manually
with <code class="docutils literal notranslate"><span class="pre">typing_extensions.Buffer.register</span></code> should use a guard to make
sure their code continues to work once <code class="docutils literal notranslate"><span class="pre">types.Buffer</span></code> is in the
standard library.</p>
</section>
<section id="no-special-meaning-for-bytes">
<h3><a class="toc-backref" href="#no-special-meaning-for-bytes">No special meaning for <code class="docutils literal notranslate"><span class="pre">bytes</span></code></a></h3>
<p>The special case stating that <code class="docutils literal notranslate"><span class="pre">bytes</span></code> may be used as a shorthand
for other <code class="docutils literal notranslate"><span class="pre">ByteString</span></code> types will be removed from the <code class="docutils literal notranslate"><span class="pre">typing</span></code>
documentation.
With <code class="docutils literal notranslate"><span class="pre">types.Buffer</span></code> available as an alternative, there will be no good
reason to allow <code class="docutils literal notranslate"><span class="pre">bytes</span></code> as a shorthand.
We suggest that type checkers currently implementing this behavior
should deprecate and eventually remove it.</p>
</section>
</section>
<section id="backwards-compatibility">
<h2><a class="toc-backref" href="#backwards-compatibility">Backwards Compatibility</a></h2>
<p>As the runtime changes in this PEP only add a new class, there are
no backwards compatibility concerns.</p>
<p>However, the recommendation to remove the special behavior for
<code class="docutils literal notranslate"><span class="pre">bytes</span></code> in type checkers does have a backwards compatibility
impact on their users. An <a class="reference external" href="https://github.com/python/mypy/pull/12661">experiment</a>
with mypy shows that several major open source projects that use it
for type checking will see new errors if the <code class="docutils literal notranslate"><span class="pre">bytes</span></code> promotion
is removed. Many of these errors can be fixed by improving
the stubs in typeshed, as has already been done for the
<a class="reference external" href="https://github.com/python/typeshed/pull/7631">builtins</a>,
<a class="reference external" href="https://github.com/python/typeshed/pull/7677">binascii</a>,
<a class="reference external" href="https://github.com/python/typeshed/pull/7678">pickle</a>, and
<a class="reference external" href="https://github.com/python/typeshed/pull/7679">re</a> modules.
Overall, the change improves type safety and makes the type system
more consistent, so we believe the migration cost is worth it.</p>
</section>
<section id="how-to-teach-this">
<h2><a class="toc-backref" href="#how-to-teach-this">How to Teach This</a></h2>
<p>We will add notes pointing to <code class="docutils literal notranslate"><span class="pre">types.Buffer</span></code> in appropriate places in the
documentation, such as <a class="reference external" href="https://typing.readthedocs.io/en/latest/">typing.readthedocs.io</a>
and the <a class="reference external" href="https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html">mypy cheat sheet</a>.
Type checkers may provide additional pointers in their error messages. For example,
when they encounter a buffer object being passed to a function that
is annotated to only accept <code class="docutils literal notranslate"><span class="pre">bytes</span></code>, the error message could include a note suggesting
the use of <code class="docutils literal notranslate"><span class="pre">types.Buffer</span></code> instead.</p>
</section>
<section id="reference-implementation">
<h2><a class="toc-backref" href="#reference-implementation">Reference Implementation</a></h2>
<p>An implementation of <code class="docutils literal notranslate"><span class="pre">types.Buffer</span></code> is
<a class="reference external" href="https://github.com/python/cpython/compare/main...JelleZijlstra:typesbuffer?expand=1">available</a>
in the author’s fork.</p>
</section>
<section id="rejected-ideas">
<h2><a class="toc-backref" href="#rejected-ideas">Rejected Ideas</a></h2>
<section id="buffer-abc">
<h3><a class="toc-backref" href="#buffer-abc">Buffer ABC</a></h3>
<p>An <a class="reference external" href="https://github.com/python/cpython/issues/71688">earlier proposal</a> suggested
adding a <code class="docutils literal notranslate"><span class="pre">collections.abc.Buffer</span></code>
<a class="reference external" href="https://docs.python.org/3/glossary.html#term-abstract-base-class">abstract base class</a>
to represent buffer objects. This idea
stalled because an ABC with no methods does not fit well into the <code class="docutils literal notranslate"><span class="pre">collections.abc</span></code>
module. Furthermore, it required manual registration of buffer classes, including
those in the standard library. This PEP’s approach of using the <code class="docutils literal notranslate"><span class="pre">__instancecheck__</span></code>
hook is more natural and does not require explicit registration.</p>
<p>Nevertheless, the ABC proposal has the advantage that it does not require C changes.
This PEP proposes to adopt a version of it in the third-party <code class="docutils literal notranslate"><span class="pre">typing_extensions</span></code>
package for the benefit of users of older Python versions.</p>
</section>
<section id="keep-bytearray-compatible-with-bytes">
<h3><a class="toc-backref" href="#keep-bytearray-compatible-with-bytes">Keep <code class="docutils literal notranslate"><span class="pre">bytearray</span></code> compatible with <code class="docutils literal notranslate"><span class="pre">bytes</span></code></a></h3>
<p>It has been suggested to remove the special case where <code class="docutils literal notranslate"><span class="pre">memoryview</span></code> is
always compatible with <code class="docutils literal notranslate"><span class="pre">bytes</span></code>, but keep it for <code class="docutils literal notranslate"><span class="pre">bytearray</span></code>, because
the two types have very similar interfaces. However, several standard
library functions (e.g., <code class="docutils literal notranslate"><span class="pre">re.compile</span></code> and <code class="docutils literal notranslate"><span class="pre">socket.getaddrinfo</span></code>) accept
<code class="docutils literal notranslate"><span class="pre">bytes</span></code> but not <code class="docutils literal notranslate"><span class="pre">bytearray</span></code>. In most codebases, <code class="docutils literal notranslate"><span class="pre">bytearray</span></code> is also
not a very common type. We prefer to have users spell out accepted types
explicitly (or use <code class="docutils literal notranslate"><span class="pre">Protocol</span></code> from <a class="pep reference internal" href="../pep-0544" title="PEP 544 – Protocols: Structural subtyping (static duck typing)">PEP 544</a> if only a specific set of
methods is required).</p>
</section>
</section>
<section id="open-issues">
<h2><a class="toc-backref" href="#open-issues">Open Issues</a></h2>
<section id="read-only-and-writable-buffers">
<h3><a class="toc-backref" href="#read-only-and-writable-buffers">Read-only and writable buffers</a></h3>
<p>To avoid making changes to the buffer protocol itself, this PEP currently
does not provide a way to distinguish between read-only and writable buffers.
That’s unfortunate, because some APIs require a writable buffer, and one of
the most common buffer types (<code class="docutils literal notranslate"><span class="pre">bytes</span></code>) is always read-only.
Should we add a new mechanism in C to declare that a type implementing the
buffer protocol is potentially writable?</p>
</section>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright">Copyright</a></h2>
<p>This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/pep-0688.rst">https://github.com/python/peps/blob/main/pep-0688.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/pep-0688.rst">2022-04-25 15:23:33 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a></li>
<li><a class="reference internal" href="#rationale">Rationale</a><ul>
<li><a class="reference internal" href="#current-options">Current options</a></li>
<li><a class="reference internal" href="#kinds-of-buffers">Kinds of buffers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#types-buffer">types.Buffer</a></li>
<li><a class="reference internal" href="#usage-in-stub-files">Usage in stub files</a></li>
<li><a class="reference internal" href="#equivalent-for-older-python-versions">Equivalent for older Python versions</a></li>
<li><a class="reference internal" href="#no-special-meaning-for-bytes">No special meaning for <code class="docutils literal notranslate"><span class="pre">bytes</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#how-to-teach-this">How to Teach This</a></li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#rejected-ideas">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#buffer-abc">Buffer ABC</a></li>
<li><a class="reference internal" href="#keep-bytearray-compatible-with-bytes">Keep <code class="docutils literal notranslate"><span class="pre">bytearray</span></code> compatible with <code class="docutils literal notranslate"><span class="pre">bytes</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#open-issues">Open Issues</a><ul>
<li><a class="reference internal" href="#read-only-and-writable-buffers">Read-only and writable buffers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br />
            <a id="source" href="https://github.com/python/peps/blob/main/pep-0688.rst">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
</body>
</html>